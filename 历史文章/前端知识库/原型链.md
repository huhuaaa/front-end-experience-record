# 原型链

## 基础概念

1. 每个对象都有__proto__属性，__proto__指向的是构造函数的prototype属性。
2. 每个函数都有prototype属性。
3. 每个原型对象都有一个constructor属性。

```javascript
// 举个例子
function Test(name) {
    this.name = name || '';
}
Test.prototype.func1 = function() {
    console.log(this.name)
}

function Test1(name) {
    Test.call(this, name)
}
// prototype为Test对象，那么prototype上也就有了constructor属性，其为function Test
Test1.prototype = new Test();
Test1.prototype.func2 = function() {
    console.log('xxx');
}

const a = new Test1('hello');
a.func1(); // print 'hello'
a.func2(); // print 'xxx'
console.log(a.construct); // 输出 function Test() { ... }；此结果，正是因为 Test1.prototype = new Test(); 这一句，将Test的实例对象赋值给Test1.prototype后，Test1.prototype就是一个Test实例对象，由于a.constructor本身没有值，在访问a.constructor时就会逐步向上寻找到a.__proto__.__proto__.constructor
console.log(a.__proto__); // Test() { ... }
```

## 老的ES5缺陷

多类型继承之后，constructor的指向会是最基础的基类。比如：
```JavaScript
function Animal(name) {
    this.name = name;
    this.legsNumber = 0;
}
Animal.prototype.printName = function() {
    console.log(this.name)
}

function Cat(name) {
    this.legsNumber = 4;
    Animal.call(this, name);
}
Cat.prototype = new Animal();
Cat.prototype.getTheNumberOfLegs = function() {
    return this.legsNumber;
}

function HelloKitty() {
    Cat.call(this, 'Hello Kitty');
}
HelloKitty.prototype = new Cat();

const kittyCat = new HelloKitty();
console.log(kittyCat.constructor);
```

## ES6的Class改进

ES6新增Class的方式，更加符合继承的概念，同时弥补了ES5时，constructor会被基类原型覆盖的问题。

```JavaScript
class Animal {
    constructor(name) {
        this.name = name;
    }

    printName() {
        console.log(this.name)
    }
}

class Cat extends Animal {
    constructor(name) {
        super(name);
        this.legsNumber = 4;
    }

    getTheNumberOfLegs() {
        return this.legsNumber;
    }
}

class HelloKitty extends Cat {
    constructor(...args) {
        super(...args);
        this.name = 'Hello Kitty';
    }
}

const kittyCat = new HelloKitty();
console.log(kittyCat.constructor)
```