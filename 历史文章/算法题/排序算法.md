# 各种排序算法

## 冒泡排序（稳定排序）

时间复杂度：O (n²)（两层循环嵌套），空间复杂度：O (1)（原地排序，无额外空间占用）。

```javascript
// 冒泡排序基础版：数组升序排列
function bubbleSort(arr) {
  // 复制原数组，避免修改原数据（可选，根据需求决定）
  const newArr = [...arr];
  const len = newArr.length;
  // 外层循环：控制排序轮数，共需 len-1 轮（最后一个元素自然有序）
  for (let i = 0; i < len - 1; i++) {
    // 内层循环：控制每轮比较次数，每轮减少 i 次（已排序的 i 个元素无需再比）
    for (let j = 0; j < len - 1 - i; j++) {
      // 相邻元素比较，前一个 > 后一个则交换（升序）
      if (newArr[j] > newArr[j + 1]) {
        // 交换方式1：解构赋值（ES6+，简洁优雅）
        [newArr[j], newArr[j + 1]] = [newArr[j + 1], newArr[j]];
        // 交换方式2：临时变量（兼容低版本JS）
        // let temp = newArr[j];
        // newArr[j] = newArr[j + 1];
        // newArr[j + 1] = temp;
      }
    }
  }
  return newArr;
}

// 测试基础版
const arr1 = [5, 2, 9, 1, 5, 6];
console.log(bubbleSort(arr1)); // 输出：[1, 2, 5, 5, 6, 9]
console.log(arr1); // 原数组未修改：[5, 2, 9, 1, 5, 6]
```

## 快速排序（非稳定排序）

1. 时间复杂度：平均 O (nlogn)（分治折半处理，效率远高于冒泡排序的 O (n²)），最坏 O (n²)（数组已有序且选边界为基准时，可通过选中间值规避）；
2. 空间复杂度：O (logn)（递归调用栈的空间，优于归并排序的 O (n)）；
3. 排序性质：不稳定排序（相等元素的相对顺序可能改变）；
4. 空间特性：非原地排序（基础版），可优化为原地排序（进阶版）；
5. 适用场景：前端开发中大部分数据排序场景（数据量中等 / 较大时效率最优），是实际开发中最常用的排序算法之一。

```javascript
// 快速排序基础版：数组升序排列
function quickSort(arr) {
  // 递归终止条件：数组长度≤1，本身已有序，直接返回
  if (arr.length <= 1) return arr;
  // 1. 选取基准值：选数组中间值，避免有序数组的最坏情况
  const pivot = arr[Math.floor(arr.length / 2)];
  // 2. 分区间：创建三个数组，分别存储小于/等于/大于基准的值
  const left = [];  // 小于基准
  const mid = [];
  const right = []; // 大于基准
  // 遍历原数组，划分到对应区间
  for (const item of arr) {
    if (item < pivot) {
      // 小于放到左侧
      left.push(item);
    } else if (item === pivot) {
      // 兼容多个值可能与中间值相等的情况
      mid.push(item);
    } else {
      // 大于的值放到右侧
      right.push(item);
    }
  }
  // 3. 排序后的结果拼接（左→中→右）
  return [...quickSort(left), ...mid, ...quickSort(right)];
}

// 测试基础版
const arr1 = [5, 2, 9, 1, 5, 6, 3];
console.log(quickSort(arr1)); // 输出：[1, 2, 3, 5, 5, 6, 9]
console.log(arr1); // 原数组未修改：[5, 2, 9, 1, 5, 6, 3]
```

```javascript
// 快速排序原地版：原地修改数组，升序排列
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  // 递归终止条件：左指针 ≥ 右指针，区间无元素/仅有一个元素，无需排序
  if (left < right) {
    // 1. 分区操作，获取基准值的最终索引
    const pivotIndex = partition(arr, left, right);
    // 2. 递归排序左子区间（基准左侧，不包含基准）
    quickSortInPlace(arr, left, pivotIndex - 1);
    // 3. 递归排序右子区间（基准右侧，不包含基准）
    quickSortInPlace(arr, pivotIndex + 1, right);
  }
  // 原地排序，返回原数组（也可直接修改，不返回）
  return arr;
}

// 分区函数：核心，实现数组分区并返回基准索引
function partition(arr, left, right) {
  // 选基准值：选右边界值（也可选左/中间/随机值，推荐随机值进一步优化）
  const pivot = arr[right];
  let i = left - 1; // 左指针：记录小于基准的元素的最后一个位置
  // 遍历区间 [left, right-1]，将小于基准的元素移到左侧
  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++; // 左指针右移，准备交换
      // 交换arr[i]和arr[j]，将小于基准的元素放到左侧
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  // 最后将基准值交换到正确位置（i+1 是基准的最终索引）
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  // 返回基准索引，用于后续递归分界
  return i + 1;
}

// 测试原地版
const arr2 = [5, 2, 9, 1, 5, 6, 3];
console.log(quickSortInPlace(arr2)); // 输出：[1, 2, 3, 5, 5, 6, 9]
console.log(arr2); // 原数组已被修改：[1, 2, 3, 5, 5, 6, 9]
```